## Client api for the nats key value store, based on JetStream

import strutils, json
import nats

# some types are generated by https://github.com/jiro4989/nimjson ty!
type
  NilType = ref object
  JsStreamListResponse = ref object
    `type`: string # "io.nats.jetstream.api.v1.stream_list_response"
    total: int64
    offset: int64
    limit: int64
    streams: seq[Streams]
  Streams = ref object
    config: Config
    created: string
    state: State
  Config = ref object
    name: string
    subjects: seq[string]
    retention: string
    max_consumers: int64
    max_msgs: int64
    max_bytes: int64
    max_age: int64
    max_msgs_per_subject: int64
    max_msg_size: int64
    `discard`: string
    storage: string
    num_replicas: int64
    duplicate_window: int64
    placement: Placement
    allow_direct: bool
    mirror_direct: bool
    sealed: bool
    deny_delete: bool
    deny_purge: bool
    allow_rollup_hdrs: bool
  Placement = ref object # TODO?
  State = ref object
    messages: int64
    bytes: int64
    first_seq: int64
    first_ts: string
    last_seq: int64
    last_ts: string
    num_subjects: int64
    consumer_count: int64



# # $JS.API.STREAM.CREATE.*
# # api.JSApiStreamCreateT
# # Creates a new Stream
# # api.StreamConfig
# # api.JSApiStreamCreateResponse

# $JS.API.STREAM.CREATE.KV_{bukname}


# type
#   StreamConfig = object

# proc createBucket(nats: Nats, bucketName: string, config: StreamConfig) =
#   ## creates a new KV Bucket
#   # $JS.API.STREAM.CREATE.*
#   let res = await nats.request()



proc splitKvSubject*(str: string): tuple[prefix, bucket, key: string] =
  ## splits a KV subject like: `$KV.tbuck.aa`
  const kvPref = "$KV"
  if str.len == 0: return
  if not str.startsWith(kvPref): return
  let parts = str[kvPref.len + 1 .. ^1].split(".", 1)
  assert parts.len == 2
  return (kvPref, parts[0], parts[1])

