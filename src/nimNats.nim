import asyncnet, asyncdispatch, uri, strutils, json, strformat,
  tables, print, parseutils

const crlf = "\c\l"
const natsHeaderMagic = "NATS/1.0"

type
  ConnectionStatus = enum
    connected
    reconnecting
    disconnected
  Verb = enum
    # Sent by server
    INFO
    MSG
    HMSG

    # Sent by client
    CONNECT
    PUB

    # Send by both
    PING
    PONG
  Message = object
    messageKind: Verb

  MsgConnect = object
    verbose: bool # : Turns on +OK protocol acknowledgements.
    pedantic: bool # : Turns on additional strict format checking, e.g. for properly formed subjects
    tls_required: bool # : Indicates whether the client requires an SSL connection.
    auth_token: string # : Client authorization token (if auth_required is set)
    user: string # : Connection username (if auth_required is set)
    pass: string # : Connection password (if auth_required is set)
    name: string # : Optional client name
    lang: string # : The implementation language of the client.
    version: string # : The version of the client.
    protocol: int # : optional int. Sending 0 (or absent) indicates client supports original protocol. Sending 1 indicates that the client supports dynamic reconfiguration of cluster topology changes by asynchronously receiving INFO messages with known servers it can reconnect to.
    `echo`: bool # : Optional boolean. If set to true, the server (version 1.2.0+) will not send originating messages from this connection to its own subscriptions. Clients should set this to true only for server supporting this feature, which is when proto in the INFO protocol is set to at least 1.
    sig: string # : In case the server has responded with a nonce on INFO, then a NATS client must use this field to reply with the signed nonce.
    jwt: string # : The JWT that identifies a user permissions and account.
    headers: bool # : Enabling Receiving of Message Headers https://github.com/nats-io/nats-architecture-and-design/blob/main/adr/ADR-4.md

  MsgPub = object
    subject: string
    replyTo: string
    payload: string

  MsgSub = object
    subject: string
    queueGroup: string
    sid: Sid

  MsgUnsub = object
    sid: Sid
    max_msgs: int

  Sid = string # A unique alphanumeric subscription ID, generated by the client

  SubscriptionCallback = proc(nats: Nats, sid: Sid, subject, payload: string, replyTo = "") {.async.}
  Subscription = object
    subject: string
    queueGroup: string # optional
    sid: Sid
    callback: SubscriptionCallback
    # reply: bool # if this is a reply subscription or not

  NatsHeaders = seq[tuple[key, val: string]]

  Nats = ref object
    sock: AsyncSocket
    # connected: bool
    debug: bool
    info: JsonNode
    subscriptions: Table[Sid, Subscription]
    # TODO add subscription to sid lookup table
    lastSidInt: int
    servers: seq[Uri]
    reconnect: bool # auto reconnect enabled?
    connectionStatus: ConnectionStatus
    isHandelingMessages: bool

proc connect(nats: Nats, urls: seq[Uri]): Future[void]

proc gensid(nats: Nats): Sid =
  nats.lastSidInt.inc
  return $nats.lastSidInt

proc `$`(msg: MsgPub): string =
  fmt"PUB {msg.subject} {msg.replyTo} {msg.payload.len}{crlf}{msg.payload}{crlf}"

proc `$`(msg: MsgConnect): string =
  # echo $*
  # echo fmt"CONNECT {$ %* msg}{crlf}"
  fmt"CONNECT {$ %* msg}{crlf}"

proc `$`(msg: MsgSub): string =
  fmt"SUB {msg.subject} {msg.queueGroup} {msg.sid}{crlf}"

proc `$`(msg: MsgUnsub): string =
  fmt"UNSUB {msg.sid} {msg.max_msgs}{crlf}"

const validHeaderKeyChars: set[char] = {33.char .. 126.char} - {':'}
const validHeaderValueChars: set[char] = AllChars - {'\c', '\l'}

proc parseHeaders*(str: string): NatsHeaders =
  ## Parses nats header
  #NATS/1.0\r\nfoo: baa
  if str.len == 0: return
  var lines = str.splitLines()
  if lines.len == 0: return
  if not lines[0].startsWith(natsHeaderMagic):
    # if nats.debug:
    # echo "[client]: invalid header magic: " & lines[0]
    return
  for line in lines[1 .. ^1]:
    var pos = 0
    var key = ""
    var val = ""
    pos += line.parseWhile(key, validHeaderKeyChars, pos)
    let colonFound = line.skip(":", pos)
    if colonFound == 0:
      # echo "ERROR No colon found... ", line
      # return @[]
      continue
    pos += colonFound
    pos += line.skip(" ", pos) # optional whitespace
    pos += line.parseWhile(val, validHeaderValueChars, pos) # TODO maybe just use the rest?
    # let parts = line.split(": ", 1)
    # if parts.len == 2:
    #   result.add (parts[0], parts[1])
    # else:
    #   # if nats.debug:
    #     # echo "[client]: invalid header line: " & line
    #   continue
    result.add (key, val)

proc newNats*(reconnect = true, debug = false): Nats =
  result = Nats()
  result.debug = debug
  result.lastSidInt = 0
  result.reconnect = reconnect
  result.connectionStatus = disconnected

proc splitMessage(str: string): tuple[verb: Verb, rest: string] =
  let parts = str.split(" ", 1)
  if parts.len == 0:
    raise newException(ValueError, "malformed response: " & str)
  try:
    result.verb = parseEnum[Verb](parts[0])
  except:
    raise newException(ValueError, "unknown verb: " & parts[0])
  if parts.len >= 2:
    result.rest = parts[1]
  else:
    result.rest = ""

proc send(nats: Nats, str: string) {.async.} =
  if nats.debug:
    echo "[send]: ", str
  await nats.sock.send(str)
# proc parseMessage(str: string): Message =
#   return

proc handleMessages(nats: Nats) {.async.} =
  nats.isHandelingMessages = true
  if nats.debug: echo "[client] start handleMessages"
  # while nats.connected:
  while nats.connectionStatus != disconnected:
    # Wait for message
    let line = await nats.sock.recvLine()
    if nats.debug:
      echo "[recv]: ", line
    if line.len == 0:
      if nats.debug: echo "[server] disconnect"

      if nats.reconnect:
        nats.connectionStatus = reconnecting
        # Automatic reconnect
        echo "[client] reconnect"
        # TODO make this better
        var urls: seq[Uri] = @[]
        for elem in nats.info["connect_urls"]:
          urls.add parseUri("nats://" & elem.getStr())
        await nats.connect(urls)
        # Tell the new server what we have supscribed
        for subscription in nats.subscriptions.values:
          echo "[client]: resubscribe"
          # resend
          let sub = MsgSub(
            subject: subscription.subject,
            queueGroup: subscription.queueGroup,
            sid: subscription.sid
          )
          await nats.send($sub)
        continue
      else:
        # nats.connected = false
        nats.connectionStatus = disconnected
        return

    let (verb, rest) = splitMessage(line)
    case verb
    of PING:
      if nats.debug:
        echo "[client] send pong"
      await nats.send "PONG" & crlf
    of PONG:
      discard #TODO reset the timeout counter
    of INFO:
      # Get informations from the server, this way we also learn about
      # new cluster servers.
      try:
        nats.info = parseJson(rest)
        echo nats.info.pretty()
      except:
        raise newException(ValueError, "could not parse the server info: " & rest)

      # Learn of new cluster nodes.
      if nats.info.hasKey("connect_urls"):
        for elem in nats.info["connect_urls"]:
          echo elem


    of MSG:
      # MSG is more complex since we must parse it but then also read
      # the payload
      # MSG <subject> <sid> [reply-to] <#bytes>␍␊[payload]␍␊
      let parts = rest.split(" ")
      var subject = ""
      var sid: Sid = ""
      var bytes = 0
      var replyTo = ""
      # no reply to
      subject = parts[0]
      sid = parts[1]
      if parts.len == 4:
        replyTo = parts[2]
      try:
        bytes = parseInt(parts[^1])
      except:
        raise newException(ValueError, "could not parse bytes from msg: " & rest)

      # parse the payload
      var payload = await nats.sock.recv(bytes)
      #print subject, sid, bytes, replyTo, payload
      # recv the crlf
      assert (await nats.sock.recv(crlf.len)) == crlf

      # call the callback
      if nats.subscriptions.hasKey(sid):
        await nats.subscriptions[sid].callback(nats, sid, subject, payload, replyTo)
      else:
        if nats.debug: echo "[err] no registered subscription!"

    of HMSG:
      # HMSG <subject> <sid> [reply-to] <#header bytes> <#total bytes>␍␊[payload]␍␊
      discard
      let parts = rest.split(" ")
      let subject = parts[0]
      let sid = parts[1]
      let replyTo = if parts.len == 5:
        parts[2]
        else:
        ""
      let headerBytes = parts[^2].parseInt()
      let totalBytes = parts[^1].parseInt()
      let wholeBody = await nats.sock.recv(totalBytes + crlf.len)
      let headerBody = wholeBody[0 .. headerBytes]
      let payload = wholeBody[headerBytes .. ^1] # TODO remove crlf?
      print subject, sid, replyTo, headerBytes,totalBytes, wholeBody, headerBody, payload

    else:
      if nats.debug:
        echo "[client] no handler for verb: ", verb




proc connect(nats: Nats, urls: seq[Uri]) {.async.} =
  for url in urls:
    # assert url.scheme == "nats"
    try:
      nats.sock = await asyncnet.dial(url.hostname, parseInt(url.port).Port)
    except:
      if nats.debug: echo "[client] could not connect to: ", url, " trying next one!"
      continue
    break
  nats.connectionStatus = connected
  # let welcome = await nats.sock.recvLine()
  # echo welcome
  # # nats.welcome = parseMessage(welcome)
  # let msg = splitMessage(welcome)
  # if msg.verb != INFO:
  #   raise newException(ValueError, "initial message is not INFO!")
  # CONNECT {"verbose":false,"pedantic":false,"tls_required":false,"name":"","lang":"go","version":"1.2.2","protocol":1}␍␊
  # send default CONNECT (client infos) #TODO change this later
  var mc = MsgConnect()
  mc.verbose = false
  mc.pedantic = false
  mc.tls_required = false
  mc.name = ""
  mc.headers = true
  # mc.lang = "nim" #TODO why error??
  # mc.version = "v0.1.0" #TODO why error??
  mc.protocol = 1
  await nats.send($mc)
  if nats.isHandelingMessages == false:
    asyncCheck nats.handleMessages()

proc pingInterval*(nats: Nats, sleepTime: int = 1_000) {.async.} =
  # while nats.connected:
  while nats.connectionStatus != disconnected:
    if nats.connectionStatus == connected:
      if nats.debug: echo "[send]: PING"
      await nats.send("PING" & crlf)
    await sleepAsync sleepTime

proc subscribe*(nats: Nats, subject: string, cb: SubscriptionCallback, queueGroup = ""): Future[Sid] {.async.} =

  let msg = MsgSub(subject: subject, queueGroup: queueGroup, sid: nats.gensid())
  var subscription = Subscription(subject: subject, queueGroup: queueGroup, sid: msg.sid, callback: cb)
  nats.subscriptions[msg.sid] = subscription
  await nats.send $msg
  return msg.sid

proc reply*(nats: Nats, subject: string, cb: SubscriptionCallback, queueGroup = "NATS-RPLY-22"): Future[Sid] {.async.} =
  ## same as subscribe but has a default queueGroup of "NATS-RPLY-22"
  return await nats.subscribe(subject, cb, queueGroup)

proc unsubscribe*(nats: Nats, sid: Sid, maxMsgs = 0) {.async.} =
  ## Unsubscribes from the given Sid
  let msg = MsgUnsub(sid: sid, max_msgs: maxMsgs)
  await nats.send $msg
  if nats.subscriptions.hasKey(sid):
    nats.subscriptions.del(sid)

proc unsubscribeSubject*(nats: Nats, subject: string, maxMsgs = 0) {.async.} =
  ## Unsubscribes all that maches a given subject
  for subscription in nats.subscriptions.values:
    if subscription.subject == subject:
      await nats.unsubscribe(subscription.sid)

proc publish*(nats: Nats, subject, payload: string, replyTo = "") {.async.} =
  ## publishes a messages to the given subject, optionally a replyTo address can be specified
  let msg = MsgPub(subject: subject, payload: payload, replyTo: replyTo)
  await nats.send $msg

when isMainModule and true:
  import unittest
  suite "nats":
    test "header1":
      let t1 = "NATS/1.0\r\nfoo: baa"
      check t1.parseHeaders() == @[("foo", "baa")]
    test "header2":
      let t1 = "NATS/1.0\r\nfoo: baa\nfoo: baa"
      check t1.parseHeaders() == @[("foo", "baa"), ("foo", "baa")]
    test "header3":
      let t1 = "NATS/1.0\r\nfoo: baa\nfoo: zaa"
      check t1.parseHeaders() == @[("foo", "baa"), ("foo", "zaa")]
    test "header4 (no space)":
      let t1 = "NATS/1.0\r\nfoo:baa\nfoo:zaa"
      check t1.parseHeaders() == @[("foo", "baa"), ("foo", "zaa")]
    test "header invalid1 (wrong magic)":
      let t1 = "NATS/1.1\r\nfoo: baa\nfoo: zaa"
      check t1.parseHeaders().len == 0
    test "header invalid2 (magic missing)":
      let t1 = "foo: baa\nfoo: zaa"
      check t1.parseHeaders().len == 0
    test "header invalid3 (disallowed space)":
      let t1 = "NATS/1.0\r\nfoo : baa\nfoo : zaa"
      check t1.parseHeaders().len == 0
    test "header invalid4 (disallowed space, ignore wrong header line)":
      let t1 = "NATS/1.0\r\nfoo : baa\nfoo: zaa"
      # echo t1.parseHeaders()
      check t1.parseHeaders() == @[("foo", "zaa")]

when isMainModule and false:
  proc handleDestinationSubject(nats: Nats, sid: Sid, subject, payload: string, replyTo: string = "") {.async.} =
    print "Callback!", sid, subject, payload, replyTo

  proc handleDestinationSubject2(nats: Nats, sid: Sid, subject, payload: string, replyTo: string = "") {.async.} =
    print "Callback22222!", sid, subject, payload, replyTo

  proc handleNeedHelp(nats: Nats, sid: Sid, subject, payload: string, replyTo: string = "") {.async.} =
    print "Need help callback", sid, subject, payload, replyTo
    await nats.publish(replyTo, "i can help!!")

  proc main(nats: Nats) {.async.} =
    await nats.connect(@[
      parseUri("nats://127.0.0.1:2134"),
      parseUri("nats://127.0.0.1:5222"),
      ])
    asyncCheck nats.pingInterval(10_000)

    let sid1 = await nats.subscribe("destination.subject", handleDestinationSubject)
    let sid2 = await nats.subscribe("destination.subject", handleDestinationSubject2)
    let sid3 = await nats.reply("help", handleNeedHelp)
    var pub = MsgPub()
    pub.subject = "destination.subject"
    # pub.replyTo = "replyAddress"
    echo $pub
    # while nats.connected:
    while nats.connectionStatus != disconnected:
      for idx in 1..10:
        pub.payload = "SOME PAYLOAD" & crlf & "HAHAHA " & $idx
        await nats.send($pub)
        await sleepAsync(1_000)

      # await nats.unsubscribe(sid1)
      await nats.unsubscribe(sid2)
      await sleepAsync(60_000)
    echo "end."

  var nats = newNats(debug = true)
  waitFor nats.main()