import asyncnet, asyncdispatch, uri, strutils, json, strformat,
  tables, print

const crlf = "\c\l"

type
  ConnectionStatus = enum
    connected
    reconnecting
    disconnected
  Verb = enum
    # Sent by server
    INFO
    MSG

    # Sent by client
    CONNECT
    PUB

    # Send by both
    PING
    PONG
  Message = object
    messageKind: Verb

  MsgConnect = object
    verbose: bool # : Turns on +OK protocol acknowledgements.
    pedantic: bool # : Turns on additional strict format checking, e.g. for properly formed subjects
    tls_required: bool # : Indicates whether the client requires an SSL connection.
    auth_token: string # : Client authorization token (if auth_required is set)
    user: string # : Connection username (if auth_required is set)
    pass: string # : Connection password (if auth_required is set)
    name: string # : Optional client name
    lang: string # : The implementation language of the client.
    version: string # : The version of the client.
    protocol: int # : optional int. Sending 0 (or absent) indicates client supports original protocol. Sending 1 indicates that the client supports dynamic reconfiguration of cluster topology changes by asynchronously receiving INFO messages with known servers it can reconnect to.
    `echo`: bool # : Optional boolean. If set to true, the server (version 1.2.0+) will not send originating messages from this connection to its own subscriptions. Clients should set this to true only for server supporting this feature, which is when proto in the INFO protocol is set to at least 1.
    sig: string # : In case the server has responded with a nonce on INFO, then a NATS client must use this field to reply with the signed nonce.
    jwt: string # : The JWT that identifies a user permissions and account.

  MsgPub = object
    subject: string
    replyTo: string
    payload: string

  MsgSub = object
    subject: string
    queueGroup: string
    sid: Sid

  MsgUnsub = object
    sid: Sid
    max_msgs: int

  Sid = string # A unique alphanumeric subscription ID, generated by the client

  SubscriptionCallback = proc(nats: Nats, sid: Sid, subject, payload: string, replyTo = "") {.async.}
  Subscription = object
    subject: string
    queueGroup: string # optional
    sid: Sid
    callback: SubscriptionCallback
    reply: bool # if this is a reply subscription or not

  Nats = ref object
    sock: AsyncSocket
    # connected: bool
    debug: bool
    info: JsonNode
    subscriptions: Table[Sid, Subscription]
    # TODO add subscription to sid lookup table
    lastSidInt: int
    servers: seq[Uri]
    reconnect: bool
    connectionStatus: ConnectionStatus
    isHandelingMessages: bool

proc connect(nats: Nats, urls: seq[Uri]): Future[void]

proc gensid(nats: Nats): Sid =
  nats.lastSidInt.inc
  return $nats.lastSidInt

proc `$`(msg: MsgPub): string =
  fmt"PUB {msg.subject} {msg.replyTo} {msg.payload.len}{crlf}{msg.payload}{crlf}"

proc `$`(msg: MsgConnect): string =
  # echo $*
  # echo fmt"CONNECT {$ %* msg}{crlf}"
  fmt"CONNECT {$ %* msg}{crlf}"

proc `$`(msg: MsgSub): string =
  fmt"SUB {msg.subject} {msg.queueGroup} {msg.sid}{crlf}"

proc `$`(msg: MsgUnsub): string =
  fmt"UNSUB {msg.sid} {msg.max_msgs}{crlf}"

proc newNats(): Nats =
  result = Nats()
  # result.connected = true
  result.debug = true
  result.lastSidInt = 0
  result.reconnect = true
  result.connectionStatus = disconnected

proc splitMessage(str: string): tuple[verb: Verb, rest: string] =
  let parts = str.split(" ", 1)
  if parts.len == 0:
    raise newException(ValueError, "malformed response: " & str)
  try:
    result.verb = parseEnum[Verb](parts[0])
  except:
    raise newException(ValueError, "unknown verb: " & parts[0])
  if parts.len >= 2:
    result.rest = parts[1]
  else:
    result.rest = ""

proc send(nats: Nats, str: string) {.async.} =
  if nats.debug:
    echo "[send]: ", str
  await nats.sock.send(str)
# proc parseMessage(str: string): Message =
#   return

proc handleMessages(nats: Nats) {.async.} =
  nats.isHandelingMessages = true
  if nats.debug: echo "[client] start handleMessages"
  # while nats.connected:
  while nats.connectionStatus != disconnected:
    # Wait for message
    let line = await nats.sock.recvLine()
    if nats.debug:
      echo "[recv]: ", line
    if line.len == 0:
      if nats.debug: echo "[server] disconnect"

      if nats.reconnect:
        nats.connectionStatus = reconnecting
        # Automatic reconnect
        echo "[client] reconnect"
        # TODO make this better
        var urls: seq[Uri] = @[]
        for elem in nats.info["connect_urls"]:
          urls.add parseUri("nats://" & elem.getStr())
        await nats.connect(urls)
        # Tell the new server what we have supscribed
        for subscription in nats.subscriptions.values:
          echo "[client]: resubscribe"
          # resend
          let sub = MsgSub(
            subject: subscription.subject,
            queueGroup: subscription.queueGroup,
            sid: subscription.sid
          )
          await nats.send($sub)
        continue
      else:
        # nats.connected = false
        nats.connectionStatus = disconnected
        return

    let (verb, rest) = splitMessage(line)
    case verb
    of PING:
      if nats.debug:
        echo "[client] send pong"
      await nats.send "PONG" & crlf
    of PONG:
      discard #TODO reset the timeout counter
    of INFO:
      # Get informations from the server, this way we also learn about
      # new cluster servers.
      try:
        nats.info = parseJson(rest)
        echo nats.info.pretty()
      except:
        raise newException(ValueError, "could not parse the server info: " & rest)

      # Learn of new cluster nodes.
      if nats.info.hasKey("connect_urls"):
        for elem in nats.info["connect_urls"]:
          echo elem


    of MSG:
      # MSG is more complex since we must parse it but then also read
      # the payload
      # MSG <subject> <sid> [reply-to] <#bytes>␍␊[payload]␍␊
      let parts = rest.split(" ")
      var subject = ""
      var sid: Sid = ""
      var bytes = 0
      var replyTo = ""
      # no reply to
      subject = parts[0]
      sid = parts[1]
      if parts.len == 4:
        replyTo = parts[2]
      try:
        bytes = parseInt(parts[^1])
      except:
        raise newException(ValueError, "could not parse bytes from msg: " & rest)

      # parse the payload
      var payload = await nats.sock.recv(bytes)
      print subject, sid, bytes, replyTo, payload
      # recv the crlf
      assert (await nats.sock.recv(crlf.len)) == crlf

      # call the callback
      if nats.subscriptions.hasKey(sid):
        await nats.subscriptions[sid].callback(nats, sid, subject, payload, replyTo)
      else:
        if nats.debug: echo "[err] no registered subscription!"

    else:
      if nats.debug:
        echo "[client] no handler for verb: ", verb


proc connect(nats: Nats, urls: seq[Uri]) {.async.} =
  for url in urls:
    # assert url.scheme == "nats"
    try:
      nats.sock = await asyncnet.dial(url.hostname, parseInt(url.port).Port)
    except:
      if nats.debug: echo "[client] could not connect to: ", url, " trying next one!"
      continue
    break
  nats.connectionStatus = connected
  # let welcome = await nats.sock.recvLine()
  # echo welcome
  # # nats.welcome = parseMessage(welcome)
  # let msg = splitMessage(welcome)
  # if msg.verb != INFO:
  #   raise newException(ValueError, "initial message is not INFO!")
  # CONNECT {"verbose":false,"pedantic":false,"tls_required":false,"name":"","lang":"go","version":"1.2.2","protocol":1}␍␊
  # send default CONNECT (client infos) #TODO change this later
  var mc = MsgConnect()
  mc.verbose = false
  mc.pedantic = false
  mc.tls_required = false
  mc.name = ""
  # mc.lang = "nim" #TODO why error??
  # mc.version = "v0.1.0" #TODO why error??
  mc.protocol = 1
  await nats.send($mc)
  if nats.isHandelingMessages == false:
    asyncCheck nats.handleMessages()

proc pingInterval(nats: Nats, sleepTime: int = 1_000) {.async.} =
  # while nats.connected:
  while nats.connectionStatus != disconnected:
    if nats.connectionStatus == connected:
      if nats.debug: echo "[send]: PING"
      await nats.send("PING" & crlf)
    await sleepAsync sleepTime

proc subscribe*(nats: Nats, subject: string, cb: SubscriptionCallback): Future[Sid] {.async.} =
  let msg = MsgSub(subject: subject, queueGroup: "", sid: nats.gensid())
  var subscription = Subscription(subject: subject, queueGroup: "", sid: msg.sid, callback: cb)
  nats.subscriptions[msg.sid] = subscription
  await nats.send $msg
  return msg.sid

proc unsubscribe*(nats: Nats, sid: Sid, maxMsgs = 0) {.async.} =
  let msg = MsgUnsub(sid: sid, max_msgs: maxMsgs)
  await nats.send $msg
  if nats.subscriptions.hasKey(sid):
    nats.subscriptions.del(sid)

# proc unsubscribe(nats: Nats, subject: Sid, maxMsgs = 0) {.async.} = # TODO

proc publish(nats: Nats, subject, payload: string, replyTo = "") {.async.} =
  let msg = MsgPub(subject: subject, payload: payload, replyTo: replyTo)
  await nats.send $msg

when isMainModule:

  proc handleDestinationSubject(nats: Nats, sid: Sid, subject, payload: string, replyTo: string = "") {.async.} =
    print "Callback!", sid, subject, payload, replyTo

  proc handleDestinationSubject2(nats: Nats, sid: Sid, subject, payload: string, replyTo: string = "") {.async.} =
    print "Callback22222!", sid, subject, payload, replyTo

  proc handleNeedHelp(nats: Nats, sid: Sid, subject, payload: string, replyTo: string = "") {.async.} =
    print "Need help callback", sid, subject, payload, replyTo
    await nats.publish(replyTo, "i can help!!")

  proc main(nats: Nats) {.async.} =
    await nats.connect(@[
      parseUri("nats://127.0.0.1:2134"),
      parseUri("nats://127.0.0.1:5222"),
      ])
    asyncCheck nats.pingInterval(10_000)

    let sid1 = await nats.subscribe("destination.subject", handleDestinationSubject)
    let sid2 = await nats.subscribe("destination.subject", handleDestinationSubject2)
    let sid3 = await nats.subscribe("help", handleNeedHelp)
    var pub = MsgPub()
    pub.subject = "destination.subject"
    # pub.replyTo = "replyAddress"
    echo $pub
    # while nats.connected:
    while nats.connectionStatus != disconnected:
      for idx in 1..10:
        pub.payload = "SOME PAYLOAD" & crlf & "HAHAHA " & $idx
        await nats.sock.send($pub)
        await sleepAsync(1_000)

      # await nats.unsubscribe(sid1)
      await nats.unsubscribe(sid2)
      await sleepAsync(60_000)
    echo "end."

  var nats = newNats()
  waitFor nats.main()