import asyncnet, asyncdispatch, uri, strutils, json, strformat,
  tables, print, parseutils, random, sets, sequtils
import std/enumerate
import headers
import types

when defined ssl:
  import net
  import openssl
  import os

export uri

type
  ConnectionError* = object of IOError
  TimeoutError* = object of IOError
  ParsingError* = object of ValueError
  NotImplementedError = object of CatchableError
  BucketDoesNotExistError* = object of CatchableError
  BucketKeyDoesNotExistError* = object of CatchableError
    key: string
    errorNumber: int

  ConnectionStatus* = enum
    connected
    reconnecting
    disconnected

  Verb* = enum
    # Sent by server
    INFO
    MSG
    HMSG
    `+OK`
    `-ERR`

    # Sent by client
    CONNECT
    PUB
    SUB
    UNSUB
    HPUB

    # Send by both
    PING
    PONG
  # Message = object
  #   messageKind: Verb

  MsgConnect* = object
    verbose: bool # : Turns on +OK protocol acknowledgements.
    pedantic: bool # : Turns on additional strict format checking, e.g. for properly formed subjects
    tls_required: bool # : Indicates whether the client requires an SSL connection.
    auth_token: string # : Client authorization token (if auth_required is set)
    user: string # : Connection username (if auth_required is set)
    pass: string # : Connection password (if auth_required is set)
    name: string # : Optional client name
    lang: string # : The implementation language of the client.
    version: string # : The version of the client.
    protocol: int # : optional int. Sending 0 (or absent) indicates client supports original protocol. Sending 1 indicates that the client supports dynamic reconfiguration of cluster topology changes by asynchronously receiving INFO messages with known servers it can reconnect to.
    `echo`: bool # : Optional boolean. If set to true, the server (version 1.2.0+) will not send originating messages from this connection to its own subscriptions. Clients should set this to true only for server supporting this feature, which is when proto in the INFO protocol is set to at least 1.
    sig: string # : In case the server has responded with a nonce on INFO, then a NATS client must use this field to reply with the signed nonce.
    jwt: string # : The JWT that identifies a user permissions and account.
    headers: bool # : Enabling Receiving of Message Headers https://github.com/nats-io/nats-architecture-and-design/blob/main/adr/ADR-4.md

  MsgPub* = object
    subject*: string
    replyTo*: string
    payload*: string

  MsgHpub* = object
    subject*: string
    replyTo*: string
    payload*: string
    headers*: NatsHeaders

  MsgSub* = object
    subject*: string
    queueGroup*: string
    sid*: Sid

  MsgUnsub* = object
    sid*: Sid
    max_msgs*: int

  MsgHmsg* = object
    sid*: Sid
    subject*: string
    payload*: string
    headers*: NatsHeaders
    replyTo*: string
    errorNumber*: int # these are in the header eg: NATS/1.0 404 Message Not Found
    errorMessage*: string # these are in the header eg: NATS/1.0 404 Message Not Found


  Sid* = string # A unique alphanumeric subscription ID, generated by the client
  Inbox* = string # A returnTo address

  SubscriptionCallback* = proc(nats: Nats, msg: MsgHmsg) {.async.}
  Subscription = object
    subject: string
    queueGroup: string # optional
    sid: Sid
    callback: SubscriptionCallback

  # User defined callbacks.
  HandlerError = proc(nats: Nats, msg: string) {.async.}
  HandlerInfo = proc(nats: Nats, info: JsonNode) {.async.}
  HandlerDisconnected = proc(nats: Nats) {.async.}
  # HandlerReconnected = proc(nats: Nats) {.async.}
  HandlerServersGained = proc(nats: Nats, servers: seq[Uri]) {.async.} # called when a new (cluster) server was discovered
  HandlerServersLost = proc(nats: Nats, servers: seq[Uri]) {.async.} # called when a (cluster) server is gone.

  Nats* = ref object
    sock: AsyncSocket
    # connected: bool
    debug*: bool
    info*: JsonNode
    subscriptions: Table[Sid, Subscription]
    requests: Table[Inbox, Future[MsgHmsg]]
    # TODO add subscription to sid lookup table
    lastSidInt: int
    servers: seq[Uri]
    tlsEnabled*: bool
    tlsServerPublicKeyPath*: string
    reconnect: bool # auto reconnect enabled?
    connectionStatus: ConnectionStatus
    isHandelingMessages*: bool
    currentServer: Uri # the server we're currently connected to
    # User defined handler/callbacks
    handlerError*: HandlerError
    handlerInfo*: HandlerInfo # called when the server sends an info eg when a new cluster server is available.
    handlerDisconnected*: HandlerDisconnected
    # handlerReconnected*: HandlerReconnected
    handlerServersGained*: HandlerServersGained
    handlerServersLost*: HandlerServersLost

  JetStream* = ref object # the jetstream context


# Forward declarations
proc connect*(nats: Nats, urls: seq[Uri]): Future[void]

proc jetstreamAvailable*(nats: Nats): bool =
  ## returns true if the server supports jetstream
  if not nats.info.hasKey("jetstream"): return false
  return nats.info["jetstream"].getBool()

proc getConnectUrls(js: JsonNode): seq[Uri] =
  if not js.isNil and js.hasKey("connect_urls"):
    for elem in js["connect_urls"]:
      result.add parseUri(elem.getStr())

proc getCurrentServer*(nats: Nats): Uri =
  ## returns the server we're currently connected to.
  return nats.currentServer

proc getAllKnownServers*(nats: Nats): seq[Uri] =
  ## return all the servers we where started with, and
  ## all servers we have learned that are in the current cluster.
  raise newException(NotImplementedError, "getAllKnownServers")

# Default handlers
proc defaultHandlerError*(nats: Nats, msg: string) {.async.} =
  raise newException(ValueError, msg)

proc defaultHandlerInfo*(nats: Nats, info: JsonNode) {.async.} =
  when not defined(release):
    echo info.pretty()

proc defaultHandlerDisconnected*(nats: Nats) {.async.} =
  when not defined(release):
    echo "[defaultHandlerDisconnected] Disconnected"

proc defaultHandlerServersGained*(nats: Nats, servers: seq[Uri]) {.async.} =
  when not defined(release):
    echo "Servers Discovered"
    for server in servers:
      echo server

proc defaultHandlerServersLost*(nats: Nats, servers: seq[Uri]) {.async.} =
  when not defined(release):
    echo "Servers Lost"
    for server in servers:
      echo server

proc genSid(nats: Nats): Sid =
  nats.lastSidInt.inc
  return $nats.lastSidInt

proc genInbox*(nats: Nats): Inbox =
  ## generates a new unique inbox
  # TODO store inboxes, to avoid collisions?
  return inboxPrefix & align($rand(int.high), inboxRandomLen, '0')


proc `$`*(msg: MsgPub): string =
  fmt"{PUB} {msg.subject} {msg.replyTo} {msg.payload.len}{crlf}{msg.payload}{crlf}"

proc `$`*(msg: MsgHpub): string =
  # HPUB <subject> [reply-to] <#header bytes> <#total bytes>␍␊[headers]␍␊␍␊[payload]␍␊
  let headerstr = $msg.headers
  fmt"{HPUB} {msg.subject} {msg.replyTo} {headerstr.len + crlf.len} {(headerstr.len + crlf.len) + msg.payload.len}{crlf}{headerstr}{crlf}{msg.payload}{crlf}"

proc `$`*(msg: MsgConnect): string =
  fmt"{CONNECT} {$ %* msg}{crlf}"

proc `$`*(msg: MsgSub): string =
  fmt"{SUB} {msg.subject} {msg.queueGroup} {msg.sid}{crlf}"

proc `$`*(msg: MsgUnsub): string =
  fmt"{UNSUB} {msg.sid} {msg.max_msgs}{crlf}"


proc newNats*(reconnect = true, debug = false): Nats =
  ## Creates a new `Nats` object
  randomize()
  result = Nats()
  result.info = %* {} # to avoid SIGSEGV: Illegal storage access
  result.debug = debug
  result.lastSidInt = 0
  result.reconnect = reconnect
  result.connectionStatus = disconnected
  result.handlerError = defaultHandlerError
  result.handlerInfo = defaultHandlerInfo
  result.handlerDisconnected = defaultHandlerDisconnected
  result.handlerServersGained = defaultHandlerServersGained
  result.handlerServersLost = defaultHandlerServersLost

proc splitMessage(str: string): tuple[verb: Verb, rest: string] =
  let parts = str.split(" ", 1)
  if parts.len == 0:
    raise newException(ParsingError, "malformed response: " & str)
  try:
    result.verb = parseEnum[Verb](parts[0])
  except:
    raise newException(ParsingError, "unknown verb: " & parts[0] & " Details: " & str)
  if parts.len >= 2:
    result.rest = parts[1]
  else:
    result.rest = ""

proc send*(nats: Nats, str: string) {.async.} =
  ## low level sending proc. Use the `$` proc's from the different `Msg*`.
  if nats.debug:
    echo "[send]: ", str.strip() # not accurate but less clutter in the console
  await nats.sock.send(str)
# proc parseMessage(str: string): Message =
#   return

proc handleMsgERR(nats: Nats, rest: string) {.async.} =
  if not nats.handlerError.isNil:
    await nats.handlerError(nats, rest)

proc handleMsgPING(nats: Nats, rest: string) {.async.} =
  if nats.debug:
    echo "[client] send pong"
  await nats.send "PONG" & crlf

proc handleMsgPONG(nats: Nats, rest: string) {.async.} =
  discard #TODO reset the timeout counter

proc computeServersGainedAndLost(nats: Nats, info: JsonNode): tuple[gained, lost: seq[Uri]] =
  let newServerSet = info.getConnectUrls().toHashSet()
  let oldServerSet = nats.info.getConnectUrls().toHashSet()
  if newServerSet == oldServerSet:
    # everything is identically, nothing to do.
    discard
  else:
    let serversGained = newServerSet - oldServerSet
    let serversLost = oldServerSet - newServerSet
    return (serversGained.toSeq(), serversLost.toSeq())


proc handleMsgINFO(nats: Nats, rest: string) {.async.} =
  # Get informations from the server, this way we also learn about
  # new cluster servers.
  var info: JsonNode = %* {} # provide an empty default
  try:
    info = parseJson(rest)
  except:
    raise newException(ParsingError, "could not parse the server info: " & rest)

  # Inform the user about servers gained and lost
  let (serversGained, serversLost) = nats.computeServersGainedAndLost(info)
  if not nats.handlerServersGained.isNil and serversGained.len > 0:
    await nats.handlerServersGained(nats, serversGained)
  if not nats.handlerServersLost.isNil and serversLost.len > 0:
    await nats.handlerServersLost(nats, serversLost)

  # Call the user defined handler
  if not nats.handlerInfo.isNil:
    if nats.debug: echo "Call user handlerInfo"
    await nats.handlerInfo(nats, info)

  if nats.debug: echo "Set info to obj"
  nats.info = info # we use the info that was passed to the handler, so a user can override some values.
  echo nats.info

  # Learn of new cluster nodes.
  # if nats.info.hasKey("connect_urls"):
  #   for elem in nats.info["connect_urls"]:
  #     echo elem
  for server in nats.info.getConnectUrls():
    echo "Cluster Server: " & $server


proc handleMsgMSG(nats: Nats, rest: string) {.async.} =
  # MSG is more complex since we must parse it but then also read
  # the payload
  # MSG <subject> <sid> [reply-to] <#bytes>␍␊[payload]␍␊
  let parts = rest.split(" ")
  var subject = ""
  var sid: Sid = ""
  var bytes = 0
  var replyTo = ""
  # no reply to
  subject = parts[0]
  sid = parts[1]
  if parts.len == 4:
    replyTo = parts[2]
  try:
    bytes = parseInt(parts[^1])
  except:
    raise newException(ParsingError, "could not parse bytes from msg: " & rest)

  # parse the payload
  var payload = await nats.sock.recv(bytes)
  payload.setLen(payload.len) # remove crlf

  #print subject, sid, bytes, replyTo, payload
  # recv the crlf
  let cc = (await nats.sock.recv(crlf.len))
  assert cc == crlf

  # call the callback
  if nats.subscriptions.hasKey(sid):
    let msg = MsgHmsg(sid: sid, subject: subject, payload: payload, headers: @[], replyTo: replyTo)
    await nats.subscriptions[sid].callback(nats, msg)
  else:
    if nats.debug: echo "[err] no registered subscription!"

proc handleMsgHMSG(nats: Nats, rest: string) {.async.} =
  # HMSG <subject> <sid> [reply-to] <#header bytes> <#total bytes>␍␊[payload]␍␊
  let parts = rest.split(" ") # TODO avoid split etc.
  let subject = parts[0]
  let sid = parts[1]
  let replyTo =
    if parts.len == 5:
      parts[2]
    else:
      ""
  let headerBytes = parts[^2].parseInt()
  let totalBytes = parts[^1].parseInt()
  let wholeBody = await nats.sock.recv(totalBytes + crlf.len)
  let headerBody = wholeBody[0 .. headerBytes]
  let payload = wholeBody[headerBytes .. ^3] # remove the crlf
  let (headers, errorNumber, errorMessage) = parseHeaders(headerBody)
  # print subject, sid, replyTo, headerBytes,totalBytes, wholeBody, headerBody, payload, headers
  # call the callback
  if nats.subscriptions.hasKey(sid):
    let msg = MsgHmsg(sid: sid, subject: subject, payload: payload, headers: headers,
      replyTo: replyTo, errorNumber: errorNumber, errorMessage: errorMessage)
    await nats.subscriptions[sid].callback(nats, msg)
  else:
    if nats.debug: echo "[err] no registered subscription!"


proc handleMessages*(nats: Nats) {.async.} =
  ## This ist the main message handler.
  ## Start this yourself
  nats.isHandelingMessages = true
  if nats.debug: echo "[client] start handleMessages"
  # while nats.connected:
  while nats.connectionStatus != disconnected:
    # Wait for message
    let line = await nats.sock.recvLine()
    if nats.debug:
      echo "[recv]: ", line
    if line.len == 0:
      if nats.debug: echo "[server] disconnect"
      if not nats.handlerDisconnected.isNil:
        await nats.handlerDisconnected(nats) # Call disconnection handler
      if nats.reconnect:
        nats.connectionStatus = reconnecting
        # Automatic reconnect
        echo "[client] reconnect"
        # TODO make this better
        var urls: seq[Uri] = @[nats.currentServer] # in every case try the current server as well.
        if nats.info.hasKey("connect_urls"):
          for elem in nats.info["connect_urls"]:
            urls.add parseUri("nats://" & elem.getStr())
        await nats.connect(urls)
        # Tell the new server what we have subscribed
        for subscription in nats.subscriptions.values:
          echo "[client]: resubscribe"
          # resend
          let sub = MsgSub(
            subject: subscription.subject,
            queueGroup: subscription.queueGroup,
            sid: subscription.sid
          )
          await nats.send($sub)
        continue
      else:
        nats.connectionStatus = disconnected
        return

    let (verb, rest) = splitMessage(line)
    case verb
    of `+OK`: discard # what else to do with them?
    of `-ERR`: await nats.handleMsgERR(rest)
    of PING: await nats.handleMsgPing(rest)
    of PONG: await nats.handleMsgPONG(rest)
    of INFO: await nats.handleMsgInfo(rest)
    of MSG: await nats.handleMsgMsg(rest)
    of HMSG: await nats.handleMsgHMSG(rest)
    else:
      if nats.debug:
        echo "[client] no handler for verb: ", verb

proc getPort(url: Uri): Port =
  ## either return the port from the uri, or the default port.
  if url.port.len == 0:
    defaulPort.Port
  else:
    parseInt(url.port).Port

proc connect*(nats: Nats, urls: seq[Uri]) {.async.} =
  ## connect to the first responding server from `urls`.
  ## After this is done, start `handleMessages`
  for url in urls:
    # assert url.scheme == "nats"
    try:
      let port = getPort(url)
      nats.sock = newAsyncSocket()
      # nats.sock = await asyncnet.dial(url.hostname, port)
      # TODO NATS effectively does "START_TLS", the first message from the server is plaintext.


      await nats.sock.connect(url.hostname, port)
      let line = await nats.sock.recvLine()

      let (verb, rest) = splitMessage(line)
      await nats.handleMsgInfo(rest)

      if nats.info.hasKey("tls_required"):
        if nats.info["tls_required"].getBool():
          echo "Server requires TLS!"
          when defined ssl:
            if nats.tlsEnabled:
              # var ctx = newContext(verifyMode = CVerifyNone) #CVerifyPeer)
              var ctx = newContext(verifyMode = CVerifyPeer)
              # if not fileExists(nats.tlsServerPublicKeyPath):
                # echo "[ERROR] could not find ssl file: ", nats.tlsServerPublicKeyPath
                # quit()
              # if 0 == SSL_CTX_load_verify_locations(ctx.context, nats.tlsServerPublicKeyPath, ""): # we gonna trust our self signed certificat
              #   echo "[ERROR] SSL_CTX_load_verify_locations returned: 0"
              #   quit()
              echo "SSL_CTX_load_verify_locations: ",  SSL_CTX_load_verify_locations(ctx.context, nats.tlsServerPublicKeyPath, "") #: # we gonna trust our self signed certificat
              wrapConnectedSocket(ctx, nats.sock, handshakeAsClient) # enables SSL for this socket.
            else:
              echo "Enable TLS!"
              quit()
          else:
            echo "Compile with -d:ssl"
            quit()
      nats.currentServer = url
      nats.connectionStatus = connected
      break
    except:
      if nats.debug: echo "[client] could not connect to: ", url, " trying next one!"
      continue
  if nats.sock.isNil:
    raise newException(ConnectionError, "could not connect to any server!")
  var mc = MsgConnect()
  mc.user = nats.currentServer.username
  mc.pass = nats.currentServer.password
  mc.verbose = false
  mc.pedantic = false
  mc.tls_required = nats.tlsEnabled
  mc.name = ""
  mc.headers = true
  mc.lang = "nim"
  mc.version = "0.1.0"
  mc.protocol = 1
  await nats.send($mc)
  # TODO maybe wait for INFO?

proc pingInterval*(nats: Nats, sleepTime: int = 1_000) {.async.} =
  ## starts to ping the server in the given interval
  ## this is optional since the server pings the client as well.
  # while nats.connected:
  while nats.connectionStatus != disconnected:
    if nats.connectionStatus == connected:
      if nats.debug: echo "[send]: PING"
      await nats.send("PING" & crlf)
    await sleepAsync sleepTime

proc subscribe*(nats: Nats, subject: string, cb: SubscriptionCallback, queueGroup = ""): Future[Sid] {.async.} =
  ## subscribes to the given subject, returns a Sid that is used to unsubscribe later.
  let msg = MsgSub(subject: subject, queueGroup: queueGroup, sid: nats.genSid())
  var subscription = Subscription(subject: subject, queueGroup: queueGroup, sid: msg.sid, callback: cb)
  nats.subscriptions[msg.sid] = subscription
  await nats.send $msg
  return msg.sid

proc reply*(nats: Nats, subject: string, cb: SubscriptionCallback, queueGroup = defaultQueueGroup): Future[Sid] {.async.} =
  ## same as subscribe but has a default queueGroup of "NATS-RPLY-22"
  return await nats.subscribe(subject, cb, queueGroup)

proc unsubscribe*(nats: Nats, sid: Sid, maxMsgs = 0) {.async.} =
  ## Unsubscribes from the given Sid (returned by subscribe)
  let msg = MsgUnsub(sid: sid, max_msgs: maxMsgs)
  await nats.send $msg
  if nats.subscriptions.hasKey(sid):
    nats.subscriptions.del(sid)

proc unsubscribeSubject*(nats: Nats, subject: string, maxMsgs = 0) {.async.} =
  ## Unsubscribes all subscriptions that maches a given subject.
  for subscription in nats.subscriptions.values:
    if subscription.subject == subject:
      await nats.unsubscribe(subscription.sid)

proc publish*(nats: Nats, subject, payload: string, replyTo = "") {.async.} =
  ## publishes a messages to the given subject, optionally a replyTo address can be specified
  let msg = MsgPub(subject: subject, payload: payload, replyTo: replyTo)
  await nats.send $msg

proc publish*(nats: Nats, subject, payload: string, headers: NatsHeaders, replyTo = "") {.async.} =
  ## publishes a messages to the given subject, optionally a replyTo address can be specified
  ## specify headers here, the message is sent as a HPUB.
  let msg = MsgHpub(subject: subject, payload: payload, headers: headers, replyTo: replyTo)
  await nats.send $msg

proc request*(nats: Nats, subject: string, payload: string = "", queueGroup = defaultQueueGroup, timeout = 5_000, headers: NatsHeaders = @[]): Future[MsgHmsg] {.async.} =
  ## awaitable
  # TODO either unsubscribe after or timeout or both
  let inbox = nats.genInbox()
  var fut = newFuture[MsgHmsg](fromProc = "request")
  var sid: Sid
  proc cb(nats: Nats, msg: MsgHmsg) {.async.} =
    fut.complete(msg)
  sid = await nats.subscribe(inbox, cb, queueGroup)
  await nats.publish(subject, payload, replyTo = inbox, headers = headers)
  var inTime = await withTimeout(fut, timeout)
  if (inTime):
    result = await fut
  else:
    fut.fail(newException(TimeoutError, "[request]: timeout"))
    result = await fut
  await nats.unsubscribe(sid)

# Jetstream ############
proc jsApiInfo*(nats: Nats): Future[JsonNode] {.async.} =
  # TODO json -> types?
  return parseJson((await nats.request("$JS.API.INFO")).payload)

type
  PlJsApiStreamCreateKv = object
    name: string
    subjects: seq[string]
# {"name":"KV_3buk","subjects":["$KV.3buk.\u003e"],"retention":"limits","max_consumers":-1,"max_msgs":-1,"max_bytes":-1,"discard":"new","max_age":0,"max_msgs_per_subject":1,"max_msg_size":-1,"storage":"file","num_replicas":1,"duplicate_window":120000000000,"placement":{"cluster":""},"deny_delete":true,"allow_rollup_hdrs":true,"allow_direct":true,"mirror_direct":false}

## A key value bucket has two modes of operandi.
## 1)
##   The first one is that every value is aquired from the NATS server on a `bucket.get("val")`
## 2)
##   The second one is, that the value(s) are aquired once on the creation and is cached in a nim table
##   then we subscribe on the buckets
##   Subjects and the server informs us about key/value changes.
##   This way the access is much faster.
type
  JsKvBucket = object
    name*: string
    nats: Nats # TODO is this good design? It allows `await bucket.get("foo")` syntax
    cache*: Table[string, string]
    # Config etc # TODO

proc addBucket*(nats: Nats, bucket: string): Future[JsKvBucket] {.async.} =
  ## adds a bucket
  let subject = fmt"$JS.API.STREAM.CREATE.KV_{bucket}"
  var pl: PlJsApiStreamCreateKv
  pl.name = fmt"KV_{bucket}"
  pl.subjects = @[fmt"$KV.{bucket}.>"]
  let res = parseJson((await nats.request(subject, $ %* pl)).payload) # TODO what to do with resp?
  echo "addBucket ", res
  return JsKvBucket(name: bucket, nats: nats)

proc remBucket*(nats: Nats, bucket: JsKvBucket): Future[void] {.async.} =
  ## removes a bucket
  # SUB _INBOX.9WlnkTv8gzdEAEBOUpFOsA.*  1
  # PUB $JS.API.STREAM.DELETE.KV_4buk _INBOX.9WlnkTv8gzdEAEBOUpFOsA.8AadBPts 0
  # ---
  # MSG _INBOX.9WlnkTv8gzdEAEBOUpFOsA.8AadBPts 1 73
  # {"type":"io.nats.jetstream.api.v1.stream_delete_response","success":true}
  let subject = fmt"$JS.API.STREAM.DELETE.{bucket.name}"
  let res = await bucket.nats.request(subject)
  # TODO parse response etcpp

proc put(bucket: JsKvBucket, key, value: string): Future[void] {.async.} =
  # PUB $KV.3buk.foo _INBOX.SdKKL4Oxk9a4LqIje3Zx6e.L7dSHjnc 11
  # http://HAHA
  let subject = fmt"$KV.{bucket.name}.{key}"
  let res = await bucket.nats.request(subject, payload = value)
  return

proc get(bucket: JsKvBucket, key: string, fetch = true): Future[string] {.async.} =
  # if fetch:
  #   let subject = fmt"$JS.API.DIRECT.GET.KV_{bucket.name}.$KV.{bucket.name}.{key}"
  #   result = (await bucket.nats.request(subject)).payload
  #   bucket.cache
  # else:
  #   if bucket.cache.hasKey(key):
  #     return bucket.cache[key]
  let subject = fmt"$JS.API.DIRECT.GET.KV_{bucket.name}.$KV.{bucket.name}.{key}"
  let hmsg = await bucket.nats.request(subject)
  if hmsg.errorNumber != 0:
    var ex = new(BucketKeyDoesNotExistError)
    ex.msg = hmsg.errorMessage
    ex.errorNumber = hmsg.errorNumber
    ex.key = key
    raise ex
  return hmsg.payload

proc del*(bucket: JsKvBucket, key: string): Future[void] {.async.} =
  ## deletes a key from the given bucket.
  # HPUB $KV.3buk.foo _INBOX.qPI2quiLioSXaDSqesMymj.EeUbg0W5 31 31
  # NATS/1.0
  # KV-Operation: DEL
  let subject = fmt"$KV.{bucket.name}.{key}"
  var headers: NatsHeaders
  headers["KV-Operation"] = "DEL"
  let res = await bucket.nats.request(subject, payload = "", headers = headers)


proc splitKvSubject(str: string): tuple[prefix, bucket, key: string] =
  ## splits a KV subject like: `$KV.tbuck.aa`
  const kvPref = "$KV"
  if str.len == 0: return
  if not str.startsWith(kvPref): return
  let parts = str[kvPref.len + 1 .. ^1].split(".", 1)
  assert parts.len == 2
  return (kvPref, parts[0], parts[1])


proc hmsgToKv*(hmsg: MsgHmsg): tuple[key, value: string] =
  ## extracts key & value from a MsgHmsg, use this in a KV bucket subscription.
  let parts = splitKvSubject(hmsg.subject)
  return (parts.key, hmsg.payload)

proc subscribe(bucket: JsKvBucket, cb: SubscriptionCallback): Future[Sid] {.async.} =
  ## Subscribes to the bucket topics, to get informed of all key/value updates
  result = await bucket.nats.subscribe(fmt"$KV.{bucket.name}.>", cb)


# proc unsubscribe(bucket: JsKvBucket)

# PUB $JS.API.DIRECT.GET.KV_3buk.$KV.3buk.foo _INBOX.V72XnFzD0ZOPxyu5Bx9Szx.aQJR292F 0

# HMSG _INBOX.V72XnFzD0ZOPxyu5Bx9Szx.aQJR292F 1  127 130
# NATS/1.0
# Nats-Stream: KV_3buk
# Nats-Subject: $KV.3buk.foo
# Nats-Sequence: 1
# Nats-Time-Stamp: 2022-10-20T18:28:52.4890681Z

# baa

# proc getKv*(nats: Nats, bucket, key: string): Future[MsgHmsg] {.async.} =
#   let subject = fmt"$JS.API.DIRECT.GET.KV_{bucket}.$KV.{bucket}.{key}"
#   result = await nats.request(subject)

when isMainModule and true:
  import os

  proc handleDestinationSubject(nats: Nats, msg: MsgHmsg) {.async.} =
    print "Callback!", msg.sid, msg.subject, msg.payload, msg.replyTo

  proc handleDestinationSubject2(nats: Nats, msg: MsgHmsg) {.async.} =
    print "Callback22222!", msg.sid, msg.subject, msg.payload, msg.replyTo

  proc handleNeedHelp(nats: Nats, msg: MsgHmsg) {.async.} =
    print "Need help callback", msg.sid, msg.subject, msg.payload, msg.replyTo
    await nats.publish(msg.replyTo, "i can help!!")

  proc printMsg(nats: Nats, msg: MsgHmsg) {.async.} =
    echo msg
    # await nats.publish(msg.replyTo, "i can help!!")


  proc main(nats: Nats) {.async.} =
    await nats.connect(@[
      # parseUri("nats://127.0.0.1:2134"),
      parseUri("nats://127.0.0.1:4222"),
      # parseUri("nats://a:b@127.0.0.1:5222"),
      # parseUri("nats://a:b@127.0.0.1:5222"),
      # parseUri("nats://a:b@127.0.0.1:4222"),
      ])
    asyncCheck nats.handleMessages()
    asyncCheck nats.pingInterval(10_000)

    print nats.jetstreamAvailable # TODO this can only be known after the info message was handled.
    if nats.jetstreamAvailable:
      echo await nats.jsApiInfo()
    var buckfoo = await nats.addBucket("3buk")
    proc buckfooCb(nats: Nats, msg: MsgHmsg) {.async.} =
      let kv = hmsgToKv(msg)
      print "Bucket updated:#############################################", kv
    let bucksid = await buckfoo.subscribe(buckfooCb)

    let sid1 = await nats.subscribe("destination.subject", handleDestinationSubject)
    let sid2 = await nats.subscribe("destination.subject", handleDestinationSubject2)
    let sid3 = await nats.reply("help", handleNeedHelp)
    let sid4 = await nats.subscribe(">", printMsg)
    var pub = MsgPub()
    pub.subject = "destination.subject"
    # pub.replyTo = "replyAddress"
    echo $pub
    # while nats.connected:

    await buckfoo.put("deleteme","DELETEME")
    while nats.connectionStatus != disconnected:
      await sleepAsync(500)
      echo "###################"
      # echo "KV:", (await nats.getKv("3buk", "foo")).payload
      await buckfoo.put("foo", $rand(1024))
      await buckfoo.put("baa", $rand(1024))
      await buckfoo.put("baz", $rand(1024))
      await buckfoo.del("deleteme")

      # echo "KV:", await buckfoo.get("foo")

      # try:
      #   echo "GET UNKNOWN:", await buckfoo.get("AAAAA")
      # except BucketKeyDoesNotExistError as ex:
      #   echo "Key Not found:"
      #   echo ex.errorNumber
      #   echo ex.msg
      #   echo "Key: ", ex.key
      #   echo "^^^^"
      # echo "###################"
      # quit()

      when false:
        for idx in 1..10:
          pub.payload = "SOME PAYLOAD" & crlf & "HAHAHA " & $idx
          await nats.publish("destination.subject", "FOO 1" & "END" , @[("aaa", "bbb"), ("foo", "baa")])
          await nats.publish("destination.subject", "", @[("no", "content"), ("foo", "baa")])
          await nats.publish("destination.subject", "", @[])
          try:
            echo "===================================="
            echo "HELP MESSAGE:",  await nats.request("AAA", "A".repeat(rand(10)) & "END")
            echo "===================================="

          except TimeoutError:
            echo "Noone wants to help me :( ", getCurrentExceptionMsg()
          # await sleepAsync(1_000)
          await sleepAsync(200)
          # await sleepAsync(50)

      # await nats.unsubscribe(sid1)
      await nats.unsubscribe(sid2)
      # await sleepAsync(60_000)
    echo "end."

  var nats = newNats(debug = true)
  nats.tlsEnabled = true
  # nats.tlsServerPublicKeyPath = getAppDir() / "examples" / "tlskeys" / "public.pem"
  # nats.tlsServerPublicKeyPath = getAppDir() /  "examples" / "tlskeys" / "public.pem"
  nats.tlsServerPublicKeyPath = getAppDir() /  "examples/tlskeys/public.pem"
  echo nats.tlsServerPublicKeyPath
  waitFor nats.main()