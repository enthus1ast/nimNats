
import uri, json, tables, strformat, strutils, asyncnet, asyncdispatch
export uri, json, tables, strformat, strutils, asyncnet, asyncdispatch

import headers
export headers

import constants
export constants




type
  ConnectionError* = object of IOError
  # TimeoutError* = object of IOError
  ParsingError* = object of ValueError
  NotImplementedError* = object of CatchableError
  BucketDoesNotExistError* = object of CatchableError
  BucketKeyDoesNotExistError* = object of CatchableError
    key*: string
    errorNumber*: int

  ConnectionStatus* = enum
    connected
    reconnecting
    disconnected

  Verb* = enum
    # Sent by server
    INFO
    MSG
    HMSG
    `+OK`
    `-ERR`

    # Sent by client
    CONNECT
    PUB
    SUB
    UNSUB
    HPUB

    # Send by both
    PING
    PONG
  # Message = object
  #   messageKind: Verb

  MsgConnect* = object
    verbose*: bool # Turns on +OK protocol acknowledgements.
    pedantic*: bool # Turns on additional strict format checking, e.g. for properly formed subjects
    tls_required*: bool # Indicates whether the client requires an SSL connection.
    auth_token*: string # Client authorization token (if auth_required is set)
    user*: string # Connection username (if auth_required is set)
    pass*: string # Connection password (if auth_required is set)
    name*: string # Optional client name
    lang*: string # The implementation language of the client.
    version*: string # The version of the client.
    protocol*: int # optional int. Sending 0 (or absent) indicates client supports original protocol. Sending 1 indicates that the client supports dynamic reconfiguration of cluster topology changes by asynchronously receiving INFO messages with known servers it can reconnect to.
    `echo`*: bool # Optional boolean. If set to true, the server (version 1.2.0+) will not send originating messages from this connection to its own subscriptions. Clients should set this to true only for server supporting this feature, which is when proto in the INFO protocol is set to at least 1.
    sig*: string # In case the server has responded with a nonce on INFO, then a NATS client must use this field to reply with the signed nonce.
    jwt*: string # The JWT that identifies a user permissions and account.
    headers*: bool # Enabling Receiving of Message Headers https://github.com/nats-io/nats-architecture-and-design/blob/main/adr/ADR-4.md

  MsgPub* = object
    subject*: string
    replyTo*: string
    payload*: string

  MsgHpub* = object
    subject*: string
    replyTo*: string
    payload*: string
    headers*: NatsHeaders

  MsgSub* = object
    subject*: string
    queueGroup*: string
    sid*: Sid

  MsgUnsub* = object
    sid*: Sid
    max_msgs*: int

  MsgHmsg* = object
    sid*: Sid
    subject*: string
    payload*: string
    headers*: NatsHeaders
    replyTo*: string
    errorNumber*: int # these are in the header eg: NATS/1.0 404 Message Not Found
    errorMessage*: string # these are in the header eg: NATS/1.0 404 Message Not Found


  Sid* = string # A unique alphanumeric subscription ID, generated by the client
  Inbox* = string # A returnTo address

  SubscriptionCallback* = proc(nats: Nats, msg: MsgHmsg) {.async.}
  Subscription* = object
    subject*: string
    queueGroup*: string # optional
    sid*: Sid
    callback*: SubscriptionCallback

  # User defined callbacks.
  HandlerError* = proc(nats: Nats, msg: string) {.async.}
  HandlerInfo* = proc(nats: Nats, info: JsonNode) {.async.}
  HandlerDisconnected* = proc(nats: Nats) {.async.}
  # HandlerReconnected* = proc(nats: Nats) {.async.}
  HandlerServersGained* = proc(nats: Nats, servers: seq[Uri]) {.async.} # called when a new (cluster) server was discovered
  HandlerServersLost* = proc(nats: Nats, servers: seq[Uri]) {.async.} # called when a (cluster) server is gone.

  Nats* = ref object
    sock*: AsyncSocket
    # connected: bool
    debug*: bool
    info*: JsonNode
    subscriptions*: Table[Sid, Subscription]
    # requests*: Table[Inbox, Future[MsgHmsg]]
    # TODO add subscription to sid lookup table
    lastSidInt: int
    servers*: seq[Uri]
    tlsEnabled*: bool
    tlsServerPublicKeyPath*: string
    reconnect*: bool # auto reconnect enabled?
    connectionStatus*: ConnectionStatus
    isHandelingMessages: bool
    currentServer*: Uri # the server we're currently connected to
    # User defined handler/callbacks
    handlerError*: HandlerError
    handlerInfo*: HandlerInfo # called when the server sends an info eg when a new cluster server is available.
    handlerDisconnected*: HandlerDisconnected
    # handlerReconnected*: HandlerReconnected
    handlerServersGained*: HandlerServersGained
    handlerServersLost*: HandlerServersLost

  JetStream* = ref object # the jetstream context
